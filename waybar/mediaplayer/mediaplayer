#!/usr/bin/env python3
# Copyright 2023 Raffaele Mancuso
# SPDX-License-Identifier: MIT
# Inspired by: https://github.com/Alexays/Waybar/blob/master/resources/custom_modules/mediaplayer.py
# This requires `playerctl`: `sudo pacman -S playerctl`
# Call it like `mediaplayerctl --player player_name`
# Find player_name with `playerctl --list-all`
import argparse
import json
import logging
import math
import subprocess
import sys
import time
from pathlib import Path
import gi
import requests
from functools import partial

gi.require_version("Playerctl", "2.0")
from gi.repository import GLib, Playerctl # noqa: E402

# Internal global variables
config = None
logger = logging.getLogger(__name__)
artfp = Path("/tmp/waybar-mediaplayer-art")
last_metadata = None
last_art_url = None
last_rot = 0
last_rot_time = 0
last_notification_time = 0
# Whether refresh_interval callback is registered
is_refint = False
format_class = None
icons = {"play": " ", "stop": " "}
is_text_rotating = None


def on_player_appeared(manager, player, selected_player=None):
    logger.debug("I was called")
    if player is not None and (
        selected_player is None or player.name == selected_player
    ):
        init_player(manager, player)
    else:
        logger.debug("New player appeared, but it's not the selected player, skipping")

    logger.debug("Returning True")
    return True

def delete_album_art():
    if artfp.is_file():
        try:
            artfp.unlink()
        except Exception:
            pass
    signal_album_art_change()

def on_player_vanished(manager, player):
    logger.info("I was called")
    write_output()
    delete_album_art()
    logger.info("Returning True")
    return True


def on_metadata(player, metadata, manager):
    logger.debug("I was called")
    update_metadata(player, metadata, manager)
    logger.debug("Returning True")
    return True


def on_playback_status(player, status, manager):
    logger.info("I was called")
    logger.debug(f"status={status}")
    # Update the icon in the progressbar (play/pause)
    logger.debug("Calling register_refresh_interval_callback")
    register_refresh_interval_callback(player, manager)
    logger.debug("Calling update_progressbar")
    update_progressbar(manager, player)
    logger.debug("Returning True")
    return True


def on_refresh_interval(manager):
    global is_refint
    logger.debug("I was called")
    # If there are no players, stop calling this handler
    if len(manager.props.players) == 0:
        logger.debug("Returning False")
        is_refint = False
        return False
    player = manager.props.players[0]
    # If we are not playing, stop calling this handler
    is_playing = player.props.status == "Playing"
    if not is_playing:
        logger.debug("Returning False")
        is_refint = False
        return False
    # Update progressbar and return
    update_progressbar(manager, player)
    logger.debug("Returning True")
    return True


def write_output(text=None, class_=None, tooltip=""):
    global config
    if not text:
        text = "" + (" " * (config["widget_length"] - 1))
    if not class_:
        class_ = gen_class(0.0)
    output = {"text": text, "class": class_, "tooltip": "<span>" + tooltip + "</span>"}
    sys.stdout.write(json.dumps(output) + "\n")
    sys.stdout.flush()


def register_refresh_interval_callback(player, manager):
    global is_refint
    logger.info("I was called")
    is_playing = player.props.status == "Playing"
    if is_playing and (not is_refint):
        logger.debug("Registering `refresh_interval` callback")
        GLib.timeout_add(config["refresh_interval"], on_refresh_interval, manager)
        is_refint = True


def rotate_str_left(s, rot):
    return s[rot:] + s[:rot]


def gen_widget_text(player):
    global last_rot, last_rot_time, is_text_rotating

    metadata = player.props.metadata
    # artist = player.get_artist()
    # artist = metadata["xesam:artist"][0]
    title = player.get_title()
    # title = metadata["xesam:title"]

    icon = icons["play"] if player.props.status != "Playing" else icons["stop"]

    if (
        player.props.player_name == "spotify"
        and "mpris:trackid" in metadata.keys()
        and ":ad:" in metadata["mpris:trackid"]
    ):
        song_info = "AD PLAYING"
    else:
        song_info = title.strip()

    if not is_text_rotating:
        text = left_text(icon + song_info)
    else:
        song_info += " " + config["sepchar"] + " "
        elapsed = (time.time() - last_rot_time) * 1000
        rot_needs_update = elapsed > config["text_rot_int"]
        if rot_needs_update:
            to_add = math.floor(elapsed / config["text_rot_int"])
            l_rot = (last_rot + to_add) % len(song_info)
            last_rot = l_rot
            last_rot_time = time.time()
        else:
            l_rot = last_rot
        song_info = rotate_str_left(song_info, l_rot)
        text = icon + song_info

    return text


def signal_album_art_change():
    cmd = ["pkill", "-RTMIN+"+str(config["image_signal"]), "waybar"]
    subprocess.run(cmd)

def download_art(art_url):
    logger.debug("Updating album art")
    resp = requests.get(art_url)
    with open(artfp, "wb") as fh:
        fh.write(resp.content)
        logger.debug(f"Album art '{art_url}' saved into '{artfp}'")
    # Update album art on bar
    signal_album_art_change()


def send_notification(summary, body):
    global last_notification_time
    cmd = [
        "notify-send",
        "--app-name=waybar-mediaplayer",
        "--icon=" + artfp,
        summary,
        body,
    ]
    logger.debug(f"Running {cmd}")
    subprocess.run(cmd)
    last_notification_time = time.time()


def update_metadata(player, metadata, manager):
    global last_notification_time, last_art_url, is_text_rotating
    logger.info("I was called")
    metadata = dict(metadata)
    # Update progressbar
    updated = update_progressbar(manager, player)
    if not updated:
        logger.debug("Progress bar not updated. Returning")
        return False
    # Download album art
    art_url = metadata.get("mpris:artUrl", None)
    if art_url and art_url != last_art_url:
        download_art(art_url)
        last_art_url = art_url
    # Notification
    notexp = time.time() - last_notification_time
    if config["is_notification"] and notexp >= config["notification_min_interval"]:
        send_notification(player.get_title(), player.get_artist())
    # Does text need rotation?
    is_text_rotating = (
        len(player.get_title()) + len(icons["stop"]) > config["widget_length"]
    )
    logger.debug("Returning")


def left_text(s):
    le = len(s)
    if le > config["widget_length"]:
        return s
    missing = config["widget_length"] - le
    s = s + " " * (missing)
    return s


def center_text(s):
    ml = max([len(x) for x in s])
    for i in range(0, len(s)):
        delta = int((ml - len(s[i])) / 2)
        s[i] = (" " * delta) + s[i]
    return s


def gen_class(perc):
    if not isinstance(perc, float):
        raise Exception(f"{perc} ({type(perc)}) is not a float")
    return "perc" + format_class(perc).replace(".", "-")


# Called
# 1. By `on_refresh_interval`
# 2. By `on_metadata`
# 3. By `on_playback_status`
def update_progressbar(manager, player):
    global last_metadata
    logger.debug("I was called")
    # Get percentage in the track
    pos = player.get_position()
    logger.debug(f"pos={pos}")
    # If it doesn't work, use CLI utility
    if pos == 0:
        cmd = ["playerctl", "--player=" + player.props.player_name, "position"]
        pos = subprocess.run(cmd, capture_output=True, text=True).stdout
        pos = float(pos) * (10**6)
        logger.debug(f"pos from CLI={pos}")
    pmetadata = player.props.metadata
    length = pmetadata["mpris:length"]
    logger.debug(f"length={length}")
    if length == 0:
        logger.debug("Length of song is 0. Faking a very long length.")
        length = 9999
        # return False
    # Compute song percentage
    perc = (pos / (length/config["length_factor"])) * 100
    perc = min(perc, 100.0)
    metadata = {
        "title": player.get_title(),
        "artist": player.get_artist(),
        "album": player.get_album(),
        "pos": pos,
        "length": length,
        "perc": perc,
    }
    if metadata == last_metadata:
        logger.debug("Metadata is the same as the last time. Returning.")
        return False
    # Check if percentage has not changed enough since last time
    elapsed = (time.time() - last_rot_time) * 1000
    rot_needs_update = elapsed > config["text_rot_int"]
    diff = metadata["perc"] - last_metadata["perc"] if last_metadata else 99999
    pbar_needs_update = diff > config["interval"]
    same_song = (
        last_metadata
        and metadata["title"] == last_metadata["title"]
        and metadata["artist"] == last_metadata["artist"]
        and metadata["album"] == last_metadata["album"]
        and metadata["length"] == last_metadata["length"]
    )
    if same_song and not pbar_needs_update and not rot_needs_update:
        logger.debug("Song is the same and neither the text nor the progressbar needs an update. Returning")
        return False
    # Write output
    widget_text = gen_widget_text(player)
    s = [metadata["title"], metadata["artist"], metadata["album"]]
    center_text(s)
    tooltip = f"<span variant='title-caps' font_weight='bold'>{s[0]}</span>\n"
    tooltip += f"{s[1]}\n"
    tooltip += f"<i>{s[2]}</i>"
    # tooltip += f"<img src='" + artfp + "'></img>"
    write_output(widget_text, gen_class(perc), tooltip)
    # It's important to return True to keep the handler going
    last_metadata = metadata
    logger.debug("Returning True")
    return True


def init_player(manager, name):
    logger.debug("I was called")
    logger.debug(f"name.name={name.name}")
    # Register handlers
    player = Playerctl.Player.new_from_name(name)
    player.connect("playback-status", on_playback_status, manager)
    player.connect("metadata", on_metadata, manager)
    manager.manage_player(player)
    # Call update_metadata to update progress bar and send notification
    logger.debug("Calling update_metadata")
    update_metadata(player, player.props.metadata, manager)
    # If we are playing, register refresh interval callback
    register_refresh_interval_callback(player, manager)
    logger.debug("Returning None")


def signal_handler(sig, frame):
    logger.debug("I was called")
    sys.stdout.write("\n")
    sys.stdout.flush()
    # loop.quit()
    sys.exit(0)


def parse_arguments():
    parser = argparse.ArgumentParser()
    # Increase verbosity with every occurrence of -v
    parser.add_argument("-v", "--verbose", action="count", default=0)
    return parser.parse_args()


def main():
    arguments = parse_arguments()

    # Initialize logging
    logging.basicConfig(
        stream=sys.stderr,
        level=logging.DEBUG,
        format="[%(funcName)s] [%(levelname)s] %(message)s",
    )

    # Logging is set by default to WARN and higher.
    # With every occurrence of -v it's lowered by one
    # until it reaches 0
    loglevel = max((3 - arguments.verbose) * 10, 0)
    logger.setLevel(loglevel)
    logging.getLogger("urllib3").setLevel(loglevel)

    # Log the sent command line arguments
    logger.info("I was called")
    logger.debug("Arguments received {}".format(vars(arguments)))

    # Read configuration from file
    fp = Path(sys.argv[0]).parent.resolve() / "config.json"
    if not fp.is_file():
        logging.critical(f"ERROR: Configuration file {fp} not found")
        sys.exit(1)
    with open(fp, "r") as fh:
        global config
        config = json.load(fh)
    assert isinstance(config,dict)

    # Remove album art if present
    delete_album_art()

    # Function to generate CSS classes
    global format_class
    interval = config["interval"]
    digits = math.floor(math.log10(interval))
    digits = max(0, math.fabs(digits))
    digits = int(digits)
    format_class = partial(lambda x,y: str(round(x, y)), y=digits)

    manager = Playerctl.PlayerManager()
    loop = GLib.MainLoop()

    # manager.connect("player-appeared", on_player_appeared)
    manager.connect("name-appeared", on_player_appeared)
    manager.connect("player-vanished", on_player_vanished)

    # signal.signal(signal.SIGINT, signal_handler)
    # signal.signal(signal.SIGTERM, signal_handler)
    # signal.signal(signal.SIGPIPE, signal.SIG_DFL)

    ini = False
    for player in manager.props.player_names:
        logger.debug(f"Found player '{player.name}'")
        if config["player_name"] is not None and config["player_name"] != player.name:
            logger.debug("This is not the filtered player, skipping it")
            continue
        logger.debug("Initializing player")
        init_player(manager, player)
        ini = True

    if not ini:
        logger.debug("No player found. Printing empty")
        write_output()

    loop.run()


if __name__ == "__main__":
    main()
